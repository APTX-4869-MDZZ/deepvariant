// Copyright 2018 Google Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from this
//    software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
syntax = "proto3";

package nucleus;

import "deepvariant/util/genomics/index.proto";
import "deepvariant/util/genomics/reference.proto";

// Describes requirements for a read for us to use it in BioTF.
message ReadRequirements {
  // By default, duplicate reads will not be kept. Set this flag to keep them.
  bool keep_duplicates = 1;
  // By default, reads that failed the vendor quality checks will not be kept.
  // Set this flag to keep them.
  bool keep_failed_vendor_quality_checks = 2;
  // By default, reads that are marked as secondary alignments will not be kept.
  // Set this flag to keep them.
  bool keep_secondary_alignments = 3;
  // By default, reads that are marked as supplementary alignments will not be
  // kept. Set this flag to keep them.
  bool keep_supplementary_alignments = 4;
  // By default, reads that aren't aligned are not kept. Set this flag to keep
  // them.
  bool keep_unaligned = 5;
  // Paired (or greater) reads that are improperly placed are not kept by
  // default. Set this flag to keep them. We define improperly placed to mean
  // reads whose (next) mate is mapped to a different contig.
  bool keep_improperly_placed = 6;
  // By default, reads with any mapping quality are kept. Setting this field
  // to a positive integer i will only keep reads that have a MAPQ >= i. Note
  // this only applies to aligned reads. If keep_unaligned is set, unaligned
  // reads, which by definition do not have a mapping quality, will still be
  // kept.
  int32 min_mapping_quality = 7;

  // Minimum base quality. This field indicates that we are enforcing a minimum
  // base quality score for a read to be used. How this field is enforced,
  // though, depends on the enum field min_base_quality_mode, as there are
  // multiple ways for this requirement to be interpreted.
  int32 min_base_quality = 8;

  // How should we enforce the min_base_quality requirement?
  enum MinBaseQualityMode {
    // If UNSPECIFIED, there are no guarantees on whether and how
    // min_base_quality would be enforced. By default we recomment
    // implementations ignore min_base_quality if this is set to UNSPECIFIED.
    UNSPECIFIED = 0;
    // The min_base_quality requirement is being enforced not by the reader but
    // by the client itself. This is commonly used when the algorithm for
    // computing whether a read satisfying the min_base_quality requirement is
    // too complex or too specific for the reader.
    ENFORCED_BY_CLIENT = 1;
  }
  MinBaseQualityMode min_base_quality_mode = 9;
}

message SamReaderOptions {
  // Read requirements that must be satisfied before our reader will return
  // a read to use.
  ReadRequirements read_requirements = 1;
  IndexHandlingMode index_mode = 2;
  // How should we handle the aux fields in the SAM record?
  enum AuxFieldHandling {
    UNSPECIFIED = 0;
    SKIP_AUX_FIELDS = 1;
    PARSE_ALL_AUX_FIELDS = 2;
  }
  AuxFieldHandling aux_field_handling = 3;

  // Block size to use in htslib, in reading the SAM/BAM. Value <=0 will use the
  // default htslib block size.
  int64 hts_block_size = 4;

  // Controls if, and at what rate, we discard reads from the input stream.
  //
  // This option allows the user to efficiently remove a random fraction of
  // reads from the source SAM/BAM file. The reads are discarded on the fly
  // before being parsed into protos, so the downsampling is reasonably
  // efficient.
  //
  // If 0.0 (the default protobuf value), this field is ignored. If != 0.0, then
  // this must be a value between (0.0, 1.0] indicating the probability p that a
  // read should be kept, or equivalently (1 - p) that a read will be kept. For
  // example, if downsample_fraction is 0.25, then each read has a 25% chance of
  // being included in the output reads.
  float downsample_fraction = 5;

  // Random seed to use with downsampling fraction.
  int64 random_seed = 6;
}

message SamHeader {
  // The VN field from the HD line.  Empty if not present (valid formats
  // will match /^[0-9]+\.[0-9]+$/).
  string format_version = 1;

  // The SO field from the HD line.
  enum SortingOrder {
    UNKNOWN = 0;
    UNSORTED = 1;
    QUERYNAME = 2;
    COORDINATE = 3;
  }
  SortingOrder sorting_order = 2;

  // The GO field from the HD line.
  enum AlignmentGrouping {
    NONE = 0;
    QUERY = 1;
    REFERENCE = 2;
  }
  AlignmentGrouping alignment_grouping = 3;

  // @SQ header field in SAM spec.
  // The order of the contigs defines the sorting order.
  repeated nucleus.genomics.v1.ContigInfo contigs = 4;

  // @RG header field in SAM spec.
  // Read groups.
  repeated ReadGroup read_groups = 5;

  // @PG header field in SAM spec.
  // A program run to generate the alignment data.
  repeated Program programs = 6;

  // @CO header field in SAM spec.
  // One-line text comments.
  repeated string comments = 7;
}

// A read group is all the data that's processed the same way by the sequencer.
message ReadGroup {
  // RG@ ID field in SAM spec.
  // The read group name.
  string name = 1;

  // RG@ CN field in SAM spec.
  // The name of the sequencing center producing the read.
  string sequencing_center = 2;

  // @RG DS field in SAM spec.
  // A free-form text description of this read group.
  string description = 3;

  // @RG DT field in SAM spec.
  string date = 4;

  // @RG FO field in SAM spec.
  string flow_order = 5;

  // @RG KS field in SAM spec.
  string key_sequence = 6;

  // @RG LB field in SAM spec.
  // A library is a collection of DNA fragments which have been prepared for
  // sequencing from a sample. This field is important for quality control as
  // error or bias can be introduced during sample preparation.
  string library_id = 7;

  // @RG PG field in SAM spec.
  repeated string program_ids = 8;

  // @RG PI field in SAM spec.
  // The predicted insert size of this read group. The insert size is the length
  // of the sequenced DNA fragment from end-to-end, not including the adapters.
  int32 predicted_insert_size = 9;

  // @RG PL field in SAM spec.
  // The platform/technology used to produce the reads.
  string platform = 10;

  // @RG PM field in SAM spec.
  // The platform model used as part of this run.
  string platform_model = 11;

  // @RG PU field in SAM spec.
  // The platform unit used as part of this experiment, for example
  // flowcell-barcode.lane for Illumina or slide for SOLiD. A unique identifier.
  string platform_unit = 12;

  // @RG SM field in SAM spec.
  // A client-supplied sample identifier for the reads in this read group.
  string sample_id = 13;
}

// A Program is used in the SAM header to track how alignment data is generated.
message Program {
  // @PG ID field in SAM spec.
  // The locally unique ID of the program. Used along with
  // `prev_program_id` to define an ordering between programs.
  string id = 2;

  // @PG PN field in SAM spec.
  // The display name of the program. This is typically the colloquial name of
  // the tool used, for example 'bwa' or 'picard'.
  string name = 3;

  // @PG CL field in SAM spec.
  // The command line used to run this program.
  string command_line = 1;

  // @PG PP field in SAM spec.
  // The ID of the program run before this one.
  string prev_program_id = 4;

  // @PG DS field in SAM spec.
  // The description of the program.
  string description = 6;

  // @PG VN field in SAM spec.
  // The version of the program run.
  string version = 5;
}

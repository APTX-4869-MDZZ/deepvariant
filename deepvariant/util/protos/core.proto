// Copyright 2018 Google Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from this
//    software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
syntax = "proto3";

package nucleus;

import "deepvariant/util/genomics/reference.proto";
import "deepvariant/util/genomics/variants.proto";

// Describes requirements for a read for us to use it in BioTF.
message ReadRequirements {
  // By default, duplicate reads will not be kept. Set this flag to keep them.
  bool keep_duplicates = 1;
  // By default, reads that failed the vendor quality checks will not be kept.
  // Set this flag to keep them.
  bool keep_failed_vendor_quality_checks = 2;
  // By default, reads that are marked as secondary alignments will not be kept.
  // Set this flag to keep them.
  bool keep_secondary_alignments = 3;
  // By default, reads that are marked as supplementary alignments will not be
  // kept. Set this flag to keep them.
  bool keep_supplementary_alignments = 4;
  // By default, reads that aren't aligned are not kept. Set this flag to keep
  // them.
  bool keep_unaligned = 5;
  // Paired (or greater) reads that are improperly placed are not kept by
  // default. Set this flag to keep them. We define improperly placed to mean
  // reads whose (next) mate is mapped to a different contig.
  bool keep_improperly_placed = 6;
  // By default, reads with any mapping quality are kept. Setting this field
  // to a positive integer i will only keep reads that have a MAPQ >= i. Note
  // this only applies to aligned reads. If keep_unaligned is set, unaligned
  // reads, which by definition do not have a mapping quality, will still be
  // kept.
  int32 min_mapping_quality = 7;

  // Minimum base quality. This field indicates that we are enforcing a minimum
  // base quality score for a read to be used. How this field is enforced,
  // though, depends on the enum field min_base_quality_mode, as there are
  // multiple ways for this requirement to be interpreted.
  int32 min_base_quality = 8;

  // How should we enforce the min_base_quality requirement?
  enum MinBaseQualityMode {
    // If UNSPECIFIED, there are no guarantees on whether and how
    // min_base_quality would be enforced. By default we recomment
    // implementations ignore min_base_quality if this is set to UNSPECIFIED.
    UNSPECIFIED = 0;
    // The min_base_quality requirement is being enforced not by the reader but
    // by the client itself. This is commonly used when the algorithm for
    // computing whether a read satisfying the min_base_quality requirement is
    // too complex or too specific for the reader.
    ENFORCED_BY_CLIENT = 1;
  }
  MinBaseQualityMode min_base_quality_mode = 9;
}

enum IndexHandlingMode {
  // Don't try to use an index.
  //  Reader: index won't be loaded; query will not work.
  //  Writer: index won't be written
  DONT_USE_INDEX = 0;
  // Expect index file, with filename based on filename of SAM/BAM/etc file.
  //  Reader: load index automatically
  //  Writer: write index automatically
  INDEX_BASED_ON_FILENAME = 1;
}

message OptionalVariantFieldsToParse {
  // These booleans are the reverse sense of what we want, to give the desired
  // default behavior.
  bool exclude_genotype = 1;
  bool exclude_genotype_likelihood = 2;
  bool exclude_genotype_quality = 3;
  bool exclude_allele_depth = 4;  // "AD" in FORMAT
  bool exclude_read_depth = 5;  // "DP" in FORMAT
  bool exclude_variant_allele_frequencies = 6;  // "VAF" in FORMAT
  bool exclude_min_read_depth = 7;  // "MIN_DP" in FORMAT, used by gVCF records
}

message VcfReaderOptions {
  // How should we handle VCF file indices?
  IndexHandlingMode index_mode = 1;
  // What FORMAT entries should we parse from every call?
  OptionalVariantFieldsToParse desired_format_entries = 2;
}

message VcfWriterOptions {
  // How should we handle VCF file indices?
  IndexHandlingMode index_mode = 1;

  // Info about the genome contigs:
  repeated nucleus.genomics.v1.ContigInfo contigs = 2;

  // Sample names
  repeated string sample_names = 3;

  // Variant filters
  repeated nucleus.genomics.v1.VcfFilterInfo filters = 4;

  // What FORMAT entries should we write out for each call?
  OptionalVariantFieldsToParse desired_format_entries = 5;

  // Should QUAL field values be rounded to one point past the decimal?
  bool round_qual_values = 6;
}

message SamReaderOptions {
  // Read requirements that must be satisfied before our reader will return
  // a read to use.
  ReadRequirements read_requirements = 1;
  IndexHandlingMode index_mode = 2;
  // How should we handle the aux fields in the SAM record?
  enum AuxFieldHandling {
    UNSPECIFIED = 0;
    SKIP_AUX_FIELDS = 1;
    PARSE_ALL_AUX_FIELDS = 2;
  }
  AuxFieldHandling aux_field_handling = 3;

  // Block size to use in htslib, in reading the SAM/BAM. Value <=0 will use the
  // default htslib block size.
  int64 hts_block_size = 4;

  // Controls if, and at what rate, we discard reads from the input stream.
  //
  // This option allows the user to efficiently remove a random fraction of
  // reads from the source SAM/BAM file. The reads are discarded on the fly
  // before being parsed into protos, so the downsampling is reasonably
  // efficient.
  //
  // If 0.0 (the default protobuf value), this field is ignored. If != 0.0, then
  // this must be a value between (0.0, 1.0] indicating the probability p that a
  // read should be kept, or equivalently (1 - p) that a read will be kept. For
  // example, if downsample_fraction is 0.25, then each read has a 25% chance of
  // being included in the output reads.
  float downsample_fraction = 5;

  // Random seed to use with downsampling fraction.
  int64 random_seed = 6;
}
